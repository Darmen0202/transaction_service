## Тестовое задание для Junior Java Developer

### Цель:
Кандидату предлагается написать микросервис, состоящий из двух API, одного клиента для обращения к внешнему API, и использующего как минимум одну базу данных для хранения бизнес-сущностей и курсов валют.

### Основные требования:
1. Сервис должен содержать два REST/SOAP/GraphQL (на выбор) API:
   - A) для приема транзакций (условно интеграция с банковскими сервисами);
   - Б) клиентский, для внешних запросов от клиента: получение списка транзакций, превысивших лимит, установление нового лимита, получение всех лимитов.

2. Покрыть документацией как минимум API, в README.md описать шаги запуска сервиса. Для описания API можно воспользоваться Swagger или аналогами.

3. Выбрать БД для хранения сущностей: PostgreSQL, MySQL, или иную. Модель данных разработать самостоятельно.

4. Скрипты миграций БД привести в том же репозитории. Крайне желательно воспользоваться Liquibase/FlyWay и подходом schema first.

5. Покрыть код unit и/или интеграционными тестами, обязательно покрыть тестами логику выставления флагов `limit_exceeded`.

6. Опубликовать в публичном репозитории в GitHub/GitLab.

7. Ознакомиться с задачей и заявить необходимое время на выполнение задания таким образом проверяется навык оценки трудоемкости задачи.

### Описание задачи:
Вы работаете Junior Java разработчиком в банке. Поступает следующая задача от руководителя:

- Требуется разработать прототип микросервиса, который будет интегрирован в существующую банковскую систему. Микросервис должен:
  1. Получать информацию о каждой расходной операции в тенге (KZT), рублях (RUB) и других валютах в реальном времени и сохранять ее в своей собственной базе данных (БД).
  2. Хранить месячный лимит по расходам в долларах США (USD) раздельно для двух категорий расходов: товаров и услуг. Если не установлен, принимать лимит равным 1000 USD.
  3. Запрашивать данные биржевых курсов валютных пар KZT/USD, RUB/USD по дневному интервалу (1day/daily) и хранить их в собственной базе данных. При расчете курсов использовать данные закрытия (close). В случае, если таковые недоступны на текущий день, использовать данные последнего закрытия (previous_close).
  4. Помечать транзакции, превысившие месячный лимит операций (технический флаг `limit_exceeded`).
  5. Дать возможность клиенту установить новый лимит. При установлении нового лимита микросервисом автоматически выставляется текущая дата.
  6. По запросу клиента возвращать список транзакций, превысивших лимит, с указанием лимита, который был превышен.

### Структура данных транзакции на входе в сервис:
- **account_from**: Банковский счет клиента (Integer, 10 знаков)
- **account_to**: Банковский счет контрагента (Integer, 10 знаков)
- **currency_shortname**: Валюта счета (String)
- **sum**: Сумма транзакции (Double, округление до сотых)
- **expense_category**: Категория расхода (String)
- **datetime**: Дата и время транзакции (Timestamp)

### Структура данных ответа:
К структуре транзакции добавляются:
- **limit_sum**: Сумма установленного лимита (Double)
- **limit_datetime**: Дата и время установления лимита (Timestamp)
- **limit_currency_shortname**: Валюта лимита (String)

### Необязательные требования:
- **1.** Реализовать параллельное выполнение алгоритма для транзакций клиента в различных валютах.
- **2.** Для хранения курсов валют предпочтительно использовать NoSQL DB Cassandra.
- **3.** Подготовить сервис к запуску в Docker; желателен скрипт Docker Compose.
- **4.** Написать CI pipeline для выбранной системы контроля версий.
- **5.** Запустить сервис на публичном сервере и приложить ссылку на API.
